## 问题



1. 首先用标志-p flag.s 运行 x86.py。该代码通过一个内存标志“实现”锁。
   你能理解汇编代码试图做什么吗？



汇编代码是一个计数器，`bx` 是次数，变量`flag` 是锁，变量`count`是计数结果



2. 使用默认值运行时，flag.s 是否按预期工作？它会产生正确的结果吗？
   使用-M 和-R 标志跟踪变量和寄存器（并打开-c 查看它们的值）。
   你能预测代码运行时标志最终会变成什么值吗？



按预期工作。产生了正确的结果。最终值是 2



3. 使用-a 标志更改寄存器%bx 的值（例如，如果只运行两个线程，就用-a bx = 2，bx = 2）。代码是做什么的？对这段代码问上面的问题，答案如何？



`bx=2,bx=2`，不影响结果；

`bx=10,bx=10`，结果发生了变化；



4. 对每个线程将 bx 设置为高值，然后使用-i 标志生成不同的中断频率。
   什么值导致产生不好的结果？什么值导致产生良好的结果？

| 中断频率 | 结果 |      |      |
| -------- | ---- | ---- | ---- |
| 1        | 50   | 10   | 96   |
| 2        | 50   | 11   | 100  |
| 3        | 67   | 12   | 88   |
| 4        | 83   | 13   | 84   |
| 5        | 88   | 14   | 86   |
| 6        | 91   | 15   | 100  |
| 7        | 83   | 16   | 90   |
| 8        | 80   | 17   | 94   |
| 9        | 94   | 18   | 77   |

循环体长度为 11，故中断值为 11 倍数时，可以保证有正确的结果

其他值都不能保证临界区的访问是原子地。



5. 现在让我们看看程序 test-and-set.s。
   首先，尝试理解使用 xchg 指令构建简单锁原语的代码。
   获取锁怎么写？释放锁如何写？

```assembly
; 获取锁
mov  $1, %ax        
xchg %ax, mutex     # atomic swap of 1 and mutex
test $0, %ax        # if we get 0 back: lock is free!
jne  .acquire       # if not, try again
```

```assembly
; 释放锁
mov  $0, mutex
```



6. 现在运行代码，再次更改中断间隔（-i）的值，并确保循环多次。
   代码是否总能按预期工作？有时会导致 CPU 使用率不高吗？如何量化呢？



总能按预期工作；

有时会导致 CPU 使用率不高；主要取决于线程是否在获取锁的时候重复循环即可。



7. 使用-P 标志生成锁相关代码的特定测试。
   例如，执行一个测试计划，在第一个线程中获取锁，但随后尝试在第二个线程中获取锁。
   正确的事情发生了吗？你还应该测试什么？



正确的事情发生了；

测试情况：

- 第一个线程获取锁，第二个线程获取锁
- 第一个线程进入临界区，第二个线程也进入临界区

```shell
python3 ./x86.py -p test-and-set.s -R ax,bx -a bx=50,bx=50 -i 18 -S -P 1100111000111000111000 -c
```



8. 现在让我们看看 peterson.s 中的代码，它实现了 Person 算法（在文中的补充栏中提到）。 研究这些代码，看看你能否理解它。



9. 现在用不同的-i 值运行代码。你看到了什么样的不同行为？

行为是一致的。



10. 你能控制调度（带-P 标志）来“证明”代码有效吗？
    你应该展示哪些不同情况？ 考虑互斥和避免死锁。



11. 现在研究 ticket.s 中 ticket 锁的代码。它是否与本章中的代码相符？

相符



12. 现在运行代码，使用以下标志：-a bx=1000, bx=1000（此标志设置每个线程循环 1000 次）。看看随着时间的推移发生了什么，线程是否花了很多时间自旋等待锁？

是,大量时间用于自旋



13. 添加更多的线程，代码表现如何？

CPU 利用率降低



14. 现在来看 yield.s，其中我们假设 yield 指令能够使一个线程将 CPU 的控制权交给另 一个线程（实际上，这会是一个 OS 原语，但为了简化仿真，我们假设有一个指令可以完成任务）。
    找到一个场景，其中 test-and-set.s 浪费周期旋转，但 yield.s 不会。
    节省了多少指令？这些节省在什么情况下会出现？

```shell
python3 x86.py -p test-and-set.s -a bx=2 -i 13 -t 4 | wc -l
python3 x86.py -p yield.s -a bx=2 -i 13 -t 4 | wc -l
```



15. 最后来看 test-and-test-and-set.s。这把锁有什么作用？
    与 test-and-set.s 相比，它实现了什么样的优点？

不懂。

参考答案：减少了写锁(`xchg`)操作, Pentium cpu 上, `xchg`需要三个时钟周期,[参考](https://sites.google.com/site/sxm0318001/pentium指令周期表) 而`mov`只需要一个时钟周期

